{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NServer: a high-level Python DNS Name Server Framework.","text":""},{"location":"#introduction","title":"Introduction","text":"<p>NServer is a Python framework for building customised DNS name servers with a focuses on ease of use over completeness. It implements high level APIs for interacting with DNS queries whilst making very few assumptions about how responses are generated.</p> <p>It is not intended to act like traditional DNS servers such as BIND or CoreDNS and should not be considered a general DNS resolver.</p> <p>NServer has been built upon dnslib however uses high level abstractions that does not give access to the full DNS specification. If this is your desired behaviour I suggest using dnslib and its server API.</p> <p>NServer has been inspired by easy to use high level frameworks such as Flask or Requests.</p> <p>Warning</p> <p>NServer is currently Beta software and does not have complete documentation, testing, or implementation of certain features.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Flexibility: Receive and respond to DNS queries using python functions</li> <li>Speed: comfortably handle 1000 queries per second on a single thread</li> <li>Protocols: supports UDP, TCP DNS queries<ul> <li>TCP server support request pipelining and connection multiplexing</li> </ul> </li> <li>Development: fully typed for your static analysis / linting needs</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Follow our Quickstart Guide.</p> TLDR<pre><code>from nserver import NameServer, Query, A\n\nserver = NameServer(\"example\")\n\n@server.rule(\"example.com\", [\"A\"])\ndef example_a_records(query: Query):\n    return A(query.name, \"1.2.3.4\")\n\nif __name__ == \"__main__\":\n    server.run()\n</code></pre>"},{"location":"#bugs-feature-requests-etc","title":"Bugs, Feature Requests etc","text":"<p>Please submit an issue on github.</p> <p>In the case of bug reports, please help us help you by following best practices <sup>1</sup> <sup>2</sup>.</p> <p>In the case of feature requests, please provide background to the problem you are trying to solve so to help find a solution that makes the most sense for the library as well as your usecase. Before making a feature request consider looking at my (roughly written) design notes.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>I am still working through open source licencing and contributing, so not taking PRs at this point in time. Instead raise and issue and I'll try get to it as soon a feasible.</p>"},{"location":"#licence","title":"Licence","text":"<p>This project is licenced under the MIT Licence - see <code>LICENCE</code>.</p> <p>This project includes other open source licenced software - see <code>NOTICE</code>.</p>"},{"location":"#authors","title":"Authors","text":"<p>A project by Nicholas Hairs - www.nicholashairs.com.</p>"},{"location":"blueprints/","title":"Blueprints","text":"<p><code>Blueprint</code>s provide a way for you to compose your application. They support most of the same functionality as a <code>NameServer</code>.</p> <p>Use cases:</p> <ul> <li>Split up your application across different blueprints for maintainability / composability.</li> <li>Reuse a blueprint registered under different rules.</li> <li>Allow custom packages to define their own rules that you can add to your own server.</li> </ul> <p>Blueprints require <code>nserver&gt;=2.0</code></p>"},{"location":"blueprints/#using-blueprints","title":"Using Blueprints","text":"<pre><code>from nserver import Blueprint, NameServer, ZoneRule, ALL_CTYPES, A\n\n# First Blueprint\nmysite = Blueprint(\"mysite\")\n\n@mysite.rule(\"nicholashairs.com\", [\"A\"])\n@mysite.rule(\"www.nicholashairs.com\", [\"A\"])\ndef nicholashairs_website(query: Query) -&gt; A:\n    return A(query.name, \"159.65.13.73\")\n\n@mysite.rule(ZoneRule, \"\", ALL_CTYPES)\ndef nicholashairs_catchall(query: Query) -&gt; None:\n    # Return empty response for all other queries\n    return None\n\n# Second Blueprint\nen_blueprint = Blueprint(\"english-speaking-blueprint\")\n\n@en_blueprint.rule(\"hello.{base_domain}\", [\"A\"])\ndef en_hello(query: Query) -&gt; A:\n    return A(query.name, \"1.1.1.1\")\n\n# Register to NameServer\nserver = NameServer(\"server\")\nserver.register_blueprint(mysite, ZoneRule, \"nicholashairs.com\", ALL_CTYPES)\nserver.register_blueprint(en_blueprint, ZoneRule, \"au\", ALL_CTYPES)\nserver.register_blueprint(en_blueprint, ZoneRule, \"nz\", ALL_CTYPES)\nserver.register_blueprint(en_blueprint, ZoneRule, \"uk\", ALL_CTYPES)\n</code></pre>"},{"location":"blueprints/#middleware-hooks-and-error-handling","title":"Middleware, Hooks, and Error Handling","text":"<p>Blueprints maintain their own <code>QueryMiddleware</code> stack which will run before any rule function is run. Included in this stack is the <code>HookMiddleware</code> and <code>ExceptionHandlerMiddleware</code>.</p>"},{"location":"blueprints/#key-differences-with-nameserver","title":"Key differences with <code>NameServer</code>","text":"<ul> <li>Does not use settings (<code>Setting</code>).</li> <li>Does not have a <code>Transport</code>.</li> <li>Does not have a <code>RawRecordMiddleware</code> stack.</li> </ul>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#200","title":"2.0.0","text":"<ul> <li>Implement Middleware<ul> <li>This includes adding error handling middleware that facilitates error handling.</li> </ul> </li> <li>Add <code>StaticRule</code> and <code>ZoneRule</code>.</li> <li>Refector <code>NameServer.rule</code> to use expanded <code>smart_make_rule</code> function.<ul> <li>Although this change should not affect rules using this decorator from being called correctly, it may change the precise rule type being used. Specifically it may use <code>StaticRule</code> instead of <code>WildcardStringRule</code> for strings with no substitutions.</li> </ul> </li> <li>Add Blueprints<ul> <li>Include refactoring <code>NameServer</code> into a new shared based <code>Scaffold</code> class.</li> </ul> </li> </ul>"},{"location":"changelog/#100","title":"1.0.0","text":"<ul> <li>Beta release</li> </ul>"},{"location":"error-handling/","title":"Error Handling","text":"<p>Custom exception handling is handled through the <code>ExceptionHandlerMiddleware</code> and <code>RawRecordExceptionHandlerMiddleware</code> Middleware. These middleware will catch any <code>Exception</code>s raised by their respective middleware stacks.</p> <p>Error handling requires <code>nserver&gt;=2.0</code></p> <p>In general you are probably able to use the <code>ExceptionHandlerMiddleware</code> as the <code>RawRecordExceptionHandlerMiddleware</code> is only needed to catch exceptions resulting from <code>RawRecordMiddleware</code> or broken exception handlers in the <code>ExceptionHandlerMiddleware</code>. If you only write <code>QueryMiddleware</code> and your <code>ExceptionHandlerMiddleware</code> handlers never raise exceptions then you'll be good to go with just the <code>ExceptionHandlerMiddleware</code>.</p> <p>Both of these middleware have a default exception handler that will be used for anything not matching a registered handler. The default handler can be overwritten by registering a handler for the <code>Exception</code> class.</p> <p>Handlers are chosen by finding a handler for the most specific parent class of the thrown exception (including the class of the exception). These classes are searched in method resolution order.</p> <p>Note</p> <p>These handlers only handle exceptions that are subclasses of (and including) <code>Exception</code>. Exceptions that are only children of <code>BaseException</code> (e.g. <code>SystemExit</code>) will not be caught by these handlers.</p>"},{"location":"error-handling/#registering-exception-handlers","title":"Registering Exception Handlers","text":"<pre><code>import dnslib\nfrom nserver import NameServer, Query, Response\n\nserver = NameServer(\"example\")\n\n@server.exception_handler(NotImplementedError)\ndef not_implemented_handler(exception: NotImplementedError, query: Query) -&gt; Response:\n    return Response(error_code=dnslib.RCODE.NOTIMPL)\n\n@server.raw_exception_handler(Exception)\ndef print_debugger(exception: Exception, record: dnslib.DNSRecord) -&gt; dnslib.DNSRecord:\n    print(f\"failed to process {record} due to {exception!r})\n    response = record.reply()\n    response.header.rcode =dnslib.RCODE.SERVFAIL\n    return response\n</code></pre>"},{"location":"external-resources/","title":"External Resources","text":"<p>Have a great project or resource that should be listed? Submit an issue on github telling us why it's awsome and we'll look at including it.</p>"},{"location":"external-resources/#projects-using-nserver","title":"Projects using NServer","text":"<p>Need inspiration? Here are some projects that use NServer:</p> <ul> <li>nhairs/domain-park: An authorative name server for securely parking domains.</li> <li>it's lonely here :(</li> </ul>"},{"location":"external-resources/#guides-blogs-talks-etc","title":"Guides, Blogs, Talks, etc","text":"<ul> <li>it's lonely here :(</li> </ul>"},{"location":"middleware/","title":"Middleware","text":"<p>Middleware can be used to modify the behaviour of a server seperate to the individual rules that are registered to the server. Middleware is run on all requests and can modify both the input and response of a request.</p> <p>Middleware requires <code>nserver&gt;=2.0</code></p>"},{"location":"middleware/#middleware-stacks","title":"Middleware Stacks","text":"<p>Middleware operates in a stack with each middleware calling the middleware below it until one returns and the result is propagated back up the chain. NServer uses two stacks, the outmost stack deals with raw DNS records (<code>RawRecordMiddleware</code>), which will eventually convert the record to a <code>Query</code> which will then be passed to the main <code>QueryMiddleware</code> stack.</p> <p>Middleware can be added to the application until it is run. Once the server begins running the middleware cannot be modified. The ordering of middleware is kept in the order in which it is added to the server; that is the first middleware registered will be called before the second and so on.</p> <p>Some middleware is automatically added when the stacks are processed.</p>"},{"location":"middleware/#querymiddleware","title":"<code>QueryMiddleware</code>","text":"<p>For most use cases you likely want to use <code>QueryMiddleware</code>. This middleware uses the high-level <code>Query</code> and <code>Response</code> objects.</p>"},{"location":"middleware/#registering-querymiddleware","title":"Registering <code>QueryMiddleware</code>","text":"<pre><code>from nserver import NameServer\nfrom nserver.middleware import QueryMiddleware\n\nserver = NameServer(\"example\")\nserver.register_middleware(QueryMiddleware())\n</code></pre>"},{"location":"middleware/#creating-your-own-querymiddleware","title":"Creating your own <code>QueryMiddleware</code>","text":"<p>Using an unmodified <code>QueryMiddleware</code> isn't very interesting as it just passes the request onto the next middleware. To add your own middleware you should subclass <code>QueryMiddleware</code> and override the <code>process_query</code> method.</p> <pre><code># ...\nfrom typing import Callable\nfrom nserver import Query, Response\n\nclass MyLoggingMiddleware(QueryMiddleware):\n    def __init__(self, logging_name: str):\n        super().__init__()\n        self.logger = logging.getLogger(f\"my-awesome-app.{name}\")\n        return\n\n    def process_query(\n        query: Query, call_next: Callable[[Query], Response]\n    ) -&gt; Response:\n        self.logger.info(f\"processing {query.name}\")\n        response = call_next(query)\n        self.logger.info(f\"done processing, returning {response.error_code}\")\n        return response\n\nserver.register_middleware(MyLoggingMiddleware(\"foo\"))\nserver.register_middleware(MyLoggingMiddleware(\"bar\"))\n</code></pre>"},{"location":"middleware/#default-querymiddleware-stack","title":"Default <code>QueryMiddleware</code> stack","text":"<p>Once processed the <code>QueryMiddleware</code> stack will look as follows:</p> <ul> <li><code>ExceptionHandlerMiddleware</code><ul> <li>Customisable error handler for <code>Exception</code>s originating from within the stack.</li> </ul> </li> <li><code>&lt;registered middleware&gt;</code></li> <li><code>HookMiddleware</code><ul> <li>Runs hooks registered to the server. This can be considered a simplified version of middleware.</li> </ul> </li> <li><code>RuleProcessor</code><ul> <li>The entry point into our rule processing.</li> </ul> </li> </ul>"},{"location":"middleware/#rawrecordmiddleware","title":"<code>RawRecordMiddleware</code>","text":"<p><code>RawRecordMiddleware</code> allows for modifying the raw <code>dnslib.DNSRecord</code>s that are recevied and sent by the server.</p>"},{"location":"middleware/#registering-rawrecordmiddleware","title":"Registering <code>RawRecordMiddleware</code>","text":"<pre><code># ...\nfrom nserver.middleware import RawRecordMiddleware\n\nserver.register_raw_middleware(RawRecordMiddleware())\n</code></pre>"},{"location":"middleware/#creating-your-own-rawrecordmiddleware","title":"Creating your own <code>RawRecordMiddleware</code>","text":"<p>Using an unmodified <code>RawRecordMiddleware</code> isn't very interesting as it just passes the request onto the next middleware. To add your own middleware you should subclass <code>RawRecordMiddleware</code> and override the <code>process_record</code> method.</p> <pre><code># ...\n\nclass SizeLimiterMiddleware(RawRecordMiddleware):\n    def __init__(self, max_size: int):\n        super().__init__()\n        self.max_size = max_size\n        return\n\n    def process_record(\n        record: dnslib.DNSRecord,\n        call_next: Callable[[dnslib.DNSRecord], dnslib.DNSRecord],\n    ) -&gt; dnslib.DNSRecord:\n        refused = record.reply()\n        refused.header.rcode = dnslib.RCODE.REFUSED\n\n        if len(record.pack()) &gt; self.max_size:\n            return refused\n\n        response = call_next(query)\n\n        if len(response.pack()) &gt; self.max_size:\n            return refused\n\n        return response\n\nserver.register_raw_middleware(SizeLimiterMiddleware(1400))\n</code></pre>"},{"location":"middleware/#default-rawrecordmiddleware-stack","title":"Default <code>RawRecordMiddleware</code> stack","text":"<p>Once processed the <code>RawRecordMiddleware</code> stack will look as follows:</p> <ul> <li><code>RawRecordExceptionHandlerMiddleware</code><ul> <li>Customisable error handler for <code>Exception</code>s originating from within the stack.</li> </ul> </li> <li><code>&lt;registered raw middleware&gt;</code></li> <li><code>QueryMiddlewareProcessor</code><ul> <li>entry point into the <code>QueryMiddleware</code> stack.</li> </ul> </li> </ul>"},{"location":"production-deployment/","title":"Production Deployment","text":"<p>Although NServer applications can be exposed directly, for production deployments it's recommended that you run your NServer application behind a reverse proxy (similar to how you would run HTTP application with uWSGI or NGINX).</p> <p>There are a few reasons for this:</p> <ul> <li>NServer is currently beta software. Although care has been taken when writing the server, it has not been thoroughly tested for bugs, nor has it had a security assessment done.</li> <li>The server is single threaded and queries will be handled one at a time.</li> <li>The server currently only provides UDP and TCP queries - it does not support DNS-over-HTTPS nor are there plans to do so.</li> <li>Public DNS resolvers and name servers are regularly targetted for all kinds of attacks. Rather than re-implementing defences such as rate-limiting we can re-use existing mechanisms.</li> <li>NServer does not currently include response caching.</li> </ul>"},{"location":"production-deployment/#deployment-using-coredns","title":"Deployment using CoreDNS","text":"<p>CoreDNS is a extendable DNS server written in Go. It has many plugins available which we can use to quickly configure our public facing servers allowing us to keep our NServer application private.</p> <p>In order to get the most performance out of our NServer instance we should operate it using the <code>TCPv4</code> transport as this will allow CoreDNS to reuse the connection for many queries whilst ensuring that even under high load queries are not lost.</p> <p>Note</p> <p>The following Corefile uses external plugins which will require you to build CoreDNS with the external plugins.</p> sample.corefile<pre><code># send all requests to this block (.) and use standard DNS port (53).\n.:53 {\n    # bind server to your public IP address\n    # note: you likely do NOT want to bind to 0.0.0.0 as this may overwrite\n    # your system's DNS resolver crippling it.\n    bind &lt;your-public-ip&gt;\n\n    # timeout if we take longer than 5001ms to respond\n    cancel\n\n    # request rate-limting\n    # plugin.cfg: ratelimit:github.com/milgradesec/ratelimit\n    ratelimit 20\n\n    # response rate-limiting\n    # (mitigate amplification attacks with response rate limiting)\n    # plugin.cfg: rrl:github.com/coredns/rrl/plugins/rrl\n    rrl . {\n        responses-per-second 10\n        requests-per-second  10\n    }\n\n    # response cache\n    cache 3600 . {\n        success 10000 3600 300\n        denial   5000 3600 300\n    }\n\n    # forward all requests (that miss the cache) to our NServer application\n    # running on the default port.\n    forward . 127.0.0.1:9953 {\n        force_tcp\n    }\n\n    # enable error logging\n    errors\n}\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#installation","title":"Installation","text":""},{"location":"quickstart/#install-via-pip","title":"Install via pip","text":"<pre><code>pip3 install nserver\n</code></pre>"},{"location":"quickstart/#minimal-server","title":"Minimal Server","text":""},{"location":"quickstart/#preparing-our-server","title":"Preparing our server","text":"minimal_server.py<pre><code>from nserver import NameServer, Query, A\n\nserver = NameServer(\"example\")\n\n@server.rule(\"example.com\", [\"A\"])\ndef example_a_records(query: Query):\n    return A(query.name, \"1.2.3.4\")\n\nif __name__ == \"__main__\":\n    server.run()\n</code></pre> <p>Here's what this code does:</p> <ol> <li> <p>To start we import:</p> <ul> <li><code>NameServer</code> - an instance of this class will contain our application</li> <li><code>Query</code> - instances of this class will be passed to our rule functions so that we can inspect the incoming DNS query</li> <li><code>A</code> - the class used to create DNS <code>A</code> records</li> </ul> </li> <li> <p>Next we create a <code>NameServer</code> instance for our application to use. The name we give the server will be used to help distinguish it from others that are also running.</p> </li> <li> <p>We then use the <code>rule</code> decorator to tell our server when to trigger our function. In this case we will trigger for <code>A</code> queries that exactly match the name <code>example.com</code>.</p> </li> <li> <p>When triggered our function will then return a single <code>A</code> record as a response.</p> </li> <li> <p>Finally we add code so that we can run our server.</p> </li> </ol>"},{"location":"quickstart/#running-our-server","title":"Running our server","text":"<p>With our server written we can now run it:</p> <pre><code>python3 example_server.py\n</code></pre> <pre><code>[INFO] Starting UDPv4Transport(address='localhost', port=9953)\n</code></pre> <p>We can access it using <code>dig</code>.</p> <pre><code>dig -p 9953 @localhost A example.com\n</code></pre> <pre><code>; &lt;&lt;&gt;&gt; DiG 9.18.12-0ubuntu0.22.04.3-Ubuntu &lt;&lt;&gt;&gt; -p 9953 @localhost A example.com\n; (1 server found)\n;; global options: +cmd\n;; Got answer:\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 20379\n;; flags: qr aa rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n\n;; QUESTION SECTION:\n;example.com.           IN  A\n\n;; ANSWER SECTION:\nexample.com.        300 IN  A   1.2.3.4\n\n;; Query time: 324 msec\n;; SERVER: 127.0.0.1#9953(localhost) (UDP)\n;; WHEN: Thu Nov 02 21:27:12 AEDT 2023\n;; MSG SIZE  rcvd: 45\n</code></pre>"},{"location":"quickstart/#rules","title":"Rules","text":"<p>Rules tell our server which queries to send to which functions. NServer ships with a number of rule types.</p> <ul> <li><code>StaticRule</code> matches on an exact string.</li> <li><code>ZoneRule</code> matches the given domain and all subdomains.</li> <li><code>WildcardStringRule</code> which allows writing rules using a shorthand syntax.</li> <li><code>RegexRule</code> which uses regular expressions for matching.</li> </ul> <p>The <code>NameServer.rule</code> decorator uses <code>smart_make_rule</code> to automatically select the \"best\" matching rule type based on the input. This will result in string (<code>str</code>) rules will be used to create either a <code>WildcardStringRule</code> or a <code>StaticRule</code>, whilst regular expression (<code>typing.Pattern</code>) rules will create a <code>RegexRule</code>. This decorator also return the original function unchanged meaning it is possible to decorate the same function with multiple rules.</p> <pre><code>@saerver.rule(\"google-dns\", [\"A\"])\ndef this_will_be_a_static_rule(query):\n    return A(query.name, \"8.8.8.8\")\n\n@server.rule(\"{base_name}\", [\"A\"])\n@server.rule(\"www.{base_name}\", [\"A\"])\n@server.rule(\"mail.{base_name}\", [\"A\"])\ndef we_only_have_three_servers_for_everything(query):\n    return list(A(query.name, f\"1.1.1.{i+1}\") for i in range(3))\n</code></pre> <p>Rules can also be added to a server by calling the <code>register_rule</code> method with an exiting rule.</p> <pre><code>from nserver import RegexRule\n\nserver.register_rule(\n    RegexRule(\n        re.compile(r\"[0-9a-f]{1-4}\\.com\"),\n        [\"A\"],\n        lambda q: return A(q.name, \"1.2.3.4\"),\n    )\n)\n</code></pre> <p>By default all rules match in a case-insensitive manner. This is the expected behaviour for name servers operating on the internet. You can override this by setting <code>case_sensitive=True</code> in the constructors or <code>rule</code> decorator.</p>"},{"location":"quickstart/#the-wildcardstringrule","title":"The <code>WildcardStringRule</code>","text":"<p>The <code>WildcardStringRule</code> allows using a shorthand notation for matching DNS names.</p> <ul> <li><code>*</code> will match a single label in the query domain</li> <li><code>**</code> will match one or more labels in the query domain (in a greedy manner)</li> <li><code>{base_name}</code> will match the \"base\" of the query name using the Public Suffix List. In general this means the \"registered\" domain for public TLDs or the last label for non-TLDs (e.g. <code>.local</code>, <code>.internal</code>).</li> </ul> <p>For example:</p> <ul> <li><code>*.example.com.au</code> will match all first level subdomains of <code>example.com.au</code>, but will not match <code>example.com.au</code> or <code>foo.bar.example.com.au</code>.</li> <li><code>**.example.com.au</code> will match all subdomains of <code>example.com.au</code> but will not match <code>example.com.au</code>.</li> <li><code>www.{base_name}</code> will match <code>www</code> on all registered and internal domains (<code>www.example.com.au</code>, <code>www.au</code>) but will not match on other subdomains, or as a registered name (<code>www.com.au</code>, <code>www.foo.au</code>)</li> </ul>"},{"location":"quickstart/#responses","title":"Responses","text":"<p>Rule functions are expected to return only the following types:</p> <ul> <li><code>None</code></li> <li>A single record instance (of any type)</li> <li>A list of record instances (of any record type, including mixed)</li> <li>A <code>Response</code> instance</li> </ul> <p>When records are returned, these will automatically be added to a <code>Response</code> instance as answer records. For simple responses this is usually enough. When <code>None</code> is returned it will be converted to an empty response.</p> <p>However if you wish to return Additional or Authority Records, or change the Error Code you will need to return a <code>Response</code> instance.</p> <p>For example a typical <code>NS</code> lookup when our application is the authoritive server for the domain may look like this:</p> <pre><code># ... server setup exlcuded\n\nfrom nserver import Response, NS, A, SOA\n\nMY_SERVERS = {\n    \"ns1.example.com\": \"1.2.3.4\",\n    \"ns2.example.com\": \"1.2.3.5\",\n    \"ns-backup.example.com\": \"9.8.7.6\",\n}\n\n@server.rule(\"example.com\", [\"NS\"])\ndef name_servers(query: Query) -&gt; Response:\n    response = Response()\n    for ns, ip in MY_SERVERS.items():\n        response.answers.append(NS(query.name, ns))\n        response.additional.append(A(ns, ip))\n    response.authority.append(SOA(\n        \"example.com\",\n        list(MY_SERVERS.keys())[0],\n        \"admin.example.com\",\n        1,\n    ))\n    return response\n</code></pre>"},{"location":"reference/nserver/","title":"Index","text":""},{"location":"reference/nserver/#nserver","title":"nserver","text":""},{"location":"reference/nserver/exceptions/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> exceptions","text":""},{"location":"reference/nserver/exceptions/#nserver.exceptions","title":"nserver.exceptions","text":""},{"location":"reference/nserver/exceptions/#nserver.exceptions.InvalidMessageError","title":"InvalidMessageError","text":"<pre><code>InvalidMessageError(\n    error: Exception,\n    raw_data: bytes,\n    remote_address: Union[str, Tuple[str, int]],\n)\n</code></pre> <p>             Bases: <code>ValueError</code></p> <p>An invalid DNS message</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The original <code>Exception</code> thrown</p> required <code>raw_data</code> <code>bytes</code> <p>Raw DNS message as pulled from the transport</p> required <code>remote_address</code> <code>Union[str, Tuple[str, int]]</code> <p>The remote end from the transport</p> required"},{"location":"reference/nserver/middleware/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> middleware","text":""},{"location":"reference/nserver/middleware/#nserver.middleware","title":"nserver.middleware","text":""},{"location":"reference/nserver/middleware/#nserver.middleware.AfterQueryHook","title":"AfterQueryHook  <code>module-attribute</code>","text":"<pre><code>AfterQueryHook = Callable[[Response], Response]\n</code></pre> <p>Type alias for <code>HookMiddleware.after_query</code> functions.</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.BeforeFirstQueryHook","title":"BeforeFirstQueryHook  <code>module-attribute</code>","text":"<pre><code>BeforeFirstQueryHook = Callable[[], None]\n</code></pre> <p>Type alias for <code>HookMiddleware.before_first_query</code> functions.</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.BeforeQueryHook","title":"BeforeQueryHook  <code>module-attribute</code>","text":"<pre><code>BeforeQueryHook = Callable[[Query], RuleResult]\n</code></pre> <p>Type alias for <code>HookMiddleware.before_query</code> functions.</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.ExceptionHandler","title":"ExceptionHandler  <code>module-attribute</code>","text":"<pre><code>ExceptionHandler = Callable[[Query, Exception], Response]\n</code></pre> <p>Type alias for <code>ExceptionHandlerMiddleware</code> exception handler functions</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.QueryMiddlewareCallable","title":"QueryMiddlewareCallable  <code>module-attribute</code>","text":"<pre><code>QueryMiddlewareCallable = Callable[[Query], Response]\n</code></pre> <p>Type alias for functions that can be used with <code>QueryMiddleware.next_function</code></p>"},{"location":"reference/nserver/middleware/#nserver.middleware.RawRecordExceptionHandler","title":"RawRecordExceptionHandler  <code>module-attribute</code>","text":"<pre><code>RawRecordExceptionHandler = Callable[\n    [dnslib.DNSRecord, Exception], dnslib.DNSRecord\n]\n</code></pre> <p>Type alias for <code>RawRecordExceptionHandlerMiddleware</code> exception handler functions</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.RawRecordMiddlewareCallable","title":"RawRecordMiddlewareCallable  <code>module-attribute</code>","text":"<pre><code>RawRecordMiddlewareCallable = Callable[\n    [dnslib.DNSRecord], dnslib.DNSRecord\n]\n</code></pre> <p>Type alias for functions that can be used with <code>RawRecordMiddleware.next_function</code></p>"},{"location":"reference/nserver/middleware/#nserver.middleware.ExceptionHandlerMiddleware","title":"ExceptionHandlerMiddleware","text":"<pre><code>ExceptionHandlerMiddleware(\n    exception_handlers: Optional[\n        Dict[Type[Exception], ExceptionHandler]\n    ] = None\n)\n</code></pre> <p>             Bases: <code>QueryMiddleware</code></p> <p>Middleware for handling exceptions originating from a <code>QueryMiddleware</code> stack.</p> <p>Allows registering handlers for individual <code>Exception</code> types. Only one handler can exist for a given <code>Exception</code> type.</p> <p>When an exception is encountered, the middleware will search for the first handler that matches the class or parent class of the exception in method resolution order. If no handler is registered will use this classes <code>self.default_exception_handler</code>.</p> <p>New in <code>2.0</code>.</p> <p>Attributes:</p> Name Type Description <code>exception_handlers</code> <p>registered exception handlers</p> <p>Parameters:</p> Name Type Description Default <code>exception_handlers</code> <code>Optional[Dict[Type[Exception], ExceptionHandler]]</code> <p>exception handlers to assign</p> <code>None</code>"},{"location":"reference/nserver/middleware/#nserver.middleware.ExceptionHandlerMiddleware.default_exception_handler","title":"default_exception_handler  <code>staticmethod</code>","text":"<pre><code>default_exception_handler(\n    query: Query, exception: Exception\n) -&gt; Response\n</code></pre> <p>The default exception handler</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.ExceptionHandlerMiddleware.get_exception_handler","title":"get_exception_handler","text":"<pre><code>get_exception_handler(\n    exception: Exception,\n) -&gt; ExceptionHandler\n</code></pre> <p>Get the exception handler for an <code>Exception</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>the exception we wish to handle</p> required"},{"location":"reference/nserver/middleware/#nserver.middleware.ExceptionHandlerMiddleware.process_query","title":"process_query","text":"<pre><code>process_query(\n    query: Query, call_next: QueryMiddlewareCallable\n) -&gt; Response\n</code></pre> <p>Call the next function catching any handling any errors</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.ExceptionHandlerMiddleware.register_next_function","title":"register_next_function","text":"<pre><code>register_next_function(\n    next_function: QueryMiddlewareCallable,\n) -&gt; None\n</code></pre> <p>Set the <code>next_function</code> of this middleware</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.HookMiddleware","title":"HookMiddleware","text":"<pre><code>HookMiddleware(\n    before_first_query: Optional[\n        List[BeforeFirstQueryHook]\n    ] = None,\n    before_query: Optional[List[BeforeQueryHook]] = None,\n    after_query: Optional[List[AfterQueryHook]] = None,\n)\n</code></pre> <p>             Bases: <code>QueryMiddleware</code></p> <p>Middleware for processing hook functions</p> <p>There are three types of hooks:</p> <p><code>before_first_query</code> hooks will be run once at the time that the first query is received. They take no arguments and return no results. These are guaranteed to run at most once - however if any hook fails it will cause no other hooks to be run. Subsequent queries will continue to be processed regardless of if all <code>before_first_query</code> hooks ran or not.</p> <p><code>before_query</code> hooks will be run before each request. They receive a <code>Query</code> as an argument. If a hooks returns a non <code>None</code> result, process will skip to result processing.</p> <p><code>after_query</code> hooks will be run after a result has been returned from a <code>before_query</code> hook or from the next function in the middleware chain. They take a <code>Response</code> input and must return a <code>Response</code>.</p> <p>New in <code>2.0</code>.</p> <p>Attributes:</p> Name Type Description <code>before_first_query</code> <code>List[BeforeFirstQueryHook]</code> <p><code>before_first_query</code> hooks</p> <code>before_query</code> <code>List[BeforeQueryHook]</code> <p><code>before_query</code> hooks</p> <code>after_query</code> <code>List[AfterQueryHook]</code> <p><code>after_query</code> hooks</p> <code>before_first_query_run</code> <code>bool</code> <p>have we run the <code>before_first_query</code> hooks</p> <code>before_first_query_failed</code> <code>bool</code> <p>did any <code>before_first_query</code> hooks fail</p> <p>Parameters:</p> Name Type Description Default <code>before_first_query</code> <code>Optional[List[BeforeFirstQueryHook]]</code> <p>initial <code>before_first_query</code> hooks to register</p> <code>None</code> <code>before_query</code> <code>Optional[List[BeforeQueryHook]]</code> <p>initial <code>before_query</code> hooks to register</p> <code>None</code> <code>after_query</code> <code>Optional[List[AfterQueryHook]]</code> <p>initial <code>after_query</code> hooks to register</p> <code>None</code>"},{"location":"reference/nserver/middleware/#nserver.middleware.HookMiddleware.process_query","title":"process_query","text":"<pre><code>process_query(\n    query: Query, call_next: QueryMiddlewareCallable\n) -&gt; Response\n</code></pre> <p>Process a query running relevant hooks.</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.HookMiddleware.register_next_function","title":"register_next_function","text":"<pre><code>register_next_function(\n    next_function: QueryMiddlewareCallable,\n) -&gt; None\n</code></pre> <p>Set the <code>next_function</code> of this middleware</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.QueryMiddleware","title":"QueryMiddleware","text":"<pre><code>QueryMiddleware()\n</code></pre> <p>Middleware for interacting with <code>Query</code> objects</p> <p>New in <code>2.0</code>.</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.QueryMiddleware.process_query","title":"process_query","text":"<pre><code>process_query(\n    query: Query, call_next: QueryMiddlewareCallable\n) -&gt; Response\n</code></pre> <p>Handle an incoming query.</p> <p>Child classes should override this function (if they do not this middleware will simply pass the query onto the next function).</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Query</code> <p>the incoming query</p> required <code>call_next</code> <code>QueryMiddlewareCallable</code> <p>the next function in the chain</p> required"},{"location":"reference/nserver/middleware/#nserver.middleware.QueryMiddleware.register_next_function","title":"register_next_function","text":"<pre><code>register_next_function(\n    next_function: QueryMiddlewareCallable,\n) -&gt; None\n</code></pre> <p>Set the <code>next_function</code> of this middleware</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.QueryMiddlewareProcessor","title":"QueryMiddlewareProcessor","text":"<pre><code>QueryMiddlewareProcessor(\n    query_middleware: QueryMiddlewareCallable,\n)\n</code></pre> <p>Convert an incoming DNS record and pass it to a <code>QueryMiddleware</code> stack.</p> <p>This class serves as the bottom of the <code>RawRcordMiddleware</code> stack.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>query_middleware</code> <code>QueryMiddlewareCallable</code> <p>the top of the middleware stack</p> required"},{"location":"reference/nserver/middleware/#nserver.middleware.RawRecordExceptionHandlerMiddleware","title":"RawRecordExceptionHandlerMiddleware","text":"<pre><code>RawRecordExceptionHandlerMiddleware(\n    exception_handlers: Optional[\n        Dict[Type[Exception], RawRecordExceptionHandler]\n    ] = None\n)\n</code></pre> <p>             Bases: <code>RawRecordMiddleware</code></p> <p>Middleware for handling exceptions originating from a <code>RawRecordMiddleware</code> stack.</p> <p>Allows registering handlers for individual <code>Exception</code> types. Only one handler can exist for a given <code>Exception</code> type.</p> <p>When an exception is encountered, the middleware will search for the first handler that matches the class or parent class of the exception in method resolution order. If no handler is registered will use this classes <code>self.default_exception_handler</code>.</p> Important <p>Exception handlers are expected to be robust - that is, they must always return correctly even if they internally encounter an <code>Exception</code>.</p> <p>New in <code>2.0</code>.</p> <p>Attributes:</p> Name Type Description <code>exception_handlers</code> <code>Dict[Type[Exception], RawRecordExceptionHandler]</code> <p>registered exception handlers</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.RawRecordExceptionHandlerMiddleware.default_exception_handler","title":"default_exception_handler  <code>staticmethod</code>","text":"<pre><code>default_exception_handler(\n    record: dnslib.DNSRecord, exception: Exception\n) -&gt; dnslib.DNSRecord\n</code></pre> <p>Default exception handler</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.RawRecordExceptionHandlerMiddleware.get_exception_handler","title":"get_exception_handler","text":"<pre><code>get_exception_handler(\n    exception: Exception,\n) -&gt; RawRecordExceptionHandler\n</code></pre> <p>Get the exception handler for the given exception</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>the exception we wish to handle</p> required"},{"location":"reference/nserver/middleware/#nserver.middleware.RawRecordExceptionHandlerMiddleware.process_record","title":"process_record","text":"<pre><code>process_record(\n    record: dnslib.DNSRecord,\n    call_next: RawRecordMiddlewareCallable,\n) -&gt; dnslib.DNSRecord\n</code></pre> <p>Call the next function handling any exceptions that arise</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.RawRecordExceptionHandlerMiddleware.register_next_function","title":"register_next_function","text":"<pre><code>register_next_function(\n    next_function: RawRecordMiddlewareCallable,\n) -&gt; None\n</code></pre> <p>Set the <code>next_function</code> of this middleware</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.RawRecordMiddleware","title":"RawRecordMiddleware","text":"<pre><code>RawRecordMiddleware()\n</code></pre> <p>Middleware to be run against raw <code>dnslib.DNSRecord</code>s.</p> <p>New in <code>2.0</code>.</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.RawRecordMiddleware.process_record","title":"process_record","text":"<pre><code>process_record(\n    record: dnslib.DNSRecord,\n    call_next: RawRecordMiddlewareCallable,\n) -&gt; dnslib.DNSRecord\n</code></pre> <p>Handle an incoming record.</p> <p>Child classes should override this function (if they do not this middleware will simply pass the record onto the next function).</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>DNSRecord</code> <p>the incoming record</p> required <code>call_next</code> <code>RawRecordMiddlewareCallable</code> <p>the next function in the chain</p> required"},{"location":"reference/nserver/middleware/#nserver.middleware.RawRecordMiddleware.register_next_function","title":"register_next_function","text":"<pre><code>register_next_function(\n    next_function: RawRecordMiddlewareCallable,\n) -&gt; None\n</code></pre> <p>Set the <code>next_function</code> of this middleware</p>"},{"location":"reference/nserver/middleware/#nserver.middleware.RuleProcessor","title":"RuleProcessor","text":"<pre><code>RuleProcessor(rules: List[RuleBase])\n</code></pre> <p>Find and run a matching rule function.</p> <p>This class serves as the bottom of the <code>QueryMiddleware</code> stack.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rules</code> <code>List[RuleBase]</code> <p>rules to run against</p> required"},{"location":"reference/nserver/middleware/#nserver.middleware.coerce_to_response","title":"coerce_to_response","text":"<pre><code>coerce_to_response(result: RuleResult) -&gt; Response\n</code></pre> <p>Convert some <code>RuleResult</code> to a <code>Response</code></p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>RuleResult</code> <p>the results to convert</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>unsupported result type</p>"},{"location":"reference/nserver/models/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> models","text":""},{"location":"reference/nserver/models/#nserver.models","title":"nserver.models","text":""},{"location":"reference/nserver/models/#nserver.models.Query","title":"Query","text":"<pre><code>Query(qtype: str, name: str)\n</code></pre> <p>Simplified version of a DNS query.</p> <p>This class acts as an adaptor for dnslib classes.</p> <p>Attributes:</p> Name Type Description <code>type</code> <p>DNS Query Type</p> <code>name</code> <p>DNS query domain name. Note: <code>.</code> is stripped by default, as such the \"root\" will be <code>\"\"</code> (empty string) rather than <code>\".\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>qtype</code> <code>str</code> <p>The DNS Query Type in string form</p> required <code>name</code> <code>str</code> <p>The name of the query</p> required"},{"location":"reference/nserver/models/#nserver.models.Query.from_dns_question","title":"from_dns_question  <code>classmethod</code>","text":"<pre><code>from_dns_question(question: dnslib.DNSQuestion) -&gt; Query\n</code></pre> <p>Create a new query from a <code>dnslib.DNSQuestion</code></p>"},{"location":"reference/nserver/models/#nserver.models.Response","title":"Response","text":"<pre><code>Response(\n    answers: OptionalRecordList = None,\n    additional: OptionalRecordList = None,\n    authority: OptionalRecordList = None,\n    error_code: int = dnslib.RCODE.NOERROR,\n)\n</code></pre> <p>Simplified version of a DNS response.</p> <p>This class acts as an adaptor for dnslib classes.</p> <p>Parameters:</p> Name Type Description Default <code>answers</code> <code>OptionalRecordList</code> <p>response answer records</p> <code>None</code> <code>additional</code> <code>OptionalRecordList</code> <p>response additional records</p> <code>None</code> <code>authority</code> <code>OptionalRecordList</code> <p>response authority records</p> <code>None</code> <code>error_code</code> <code>int</code> <p>DNS response error code</p> <code>NOERROR</code>"},{"location":"reference/nserver/models/#nserver.models.Response.get_additional_records","title":"get_additional_records","text":"<pre><code>get_additional_records() -&gt; List[dnslib.RD]\n</code></pre> <p>Prepare resource records for additional section</p>"},{"location":"reference/nserver/models/#nserver.models.Response.get_answer_records","title":"get_answer_records","text":"<pre><code>get_answer_records() -&gt; List[dnslib.RD]\n</code></pre> <p>Prepare resource records for answer section</p>"},{"location":"reference/nserver/models/#nserver.models.Response.get_authority_records","title":"get_authority_records","text":"<pre><code>get_authority_records() -&gt; List[dnslib.RD]\n</code></pre> <p>Prepare resource records for authority section</p>"},{"location":"reference/nserver/records/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> records","text":""},{"location":"reference/nserver/records/#nserver.records","title":"nserver.records","text":""},{"location":"reference/nserver/records/#nserver.records.A","title":"A","text":"<pre><code>A(\n    resource_name: str,\n    ip: Union[str, IPv4Address],\n    ttl: int = 300,\n)\n</code></pre> <p>             Bases: <code>RecordBase</code></p> <p>Ipv4 Address (<code>A</code>) Record.</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>DNS resource name</p> required <code>ip</code> <code>Union[str, IPv4Address]</code> <p>IPv4 address of the resource</p> required <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> <code>300</code>"},{"location":"reference/nserver/records/#nserver.records.A.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/records/#nserver.records.AAAA","title":"AAAA","text":"<pre><code>AAAA(\n    resource_name: str,\n    ip: Union[str, IPv6Address],\n    ttl: int = 300,\n)\n</code></pre> <p>             Bases: <code>RecordBase</code></p> <p>Ipv6 Address (<code>AAAA</code>) Record.</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>DNS resource name</p> required <code>ip</code> <code>Union[str, IPv6Address]</code> <p>IPv6 address of the resource</p> required <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> <code>300</code>"},{"location":"reference/nserver/records/#nserver.records.AAAA.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/records/#nserver.records.CAA","title":"CAA","text":"<pre><code>CAA(\n    resource_name: str,\n    flags: int,\n    tag: str,\n    value: str,\n    ttl: int = 3600,\n)\n</code></pre> <p>             Bases: <code>RecordBase</code></p> <p>Certificate Authority Authorisation (<code>CAA</code>) Record</p> See also <ul> <li>https://datatracker.ietf.org/doc/html/rfc6844</li> <li>https://support.dnsimple.com/articles/caa-record/</li> </ul> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>domain name this record applies to</p> required <code>flags</code> <code>int</code> <p>8bit numbers for flags</p> required <code>tag</code> <code>str</code> <p>type of CAA record</p> required <code>value</code> <code>str</code> <p>value for given tag (see RFC for more info)</p> required <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> <code>3600</code>"},{"location":"reference/nserver/records/#nserver.records.CAA.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/records/#nserver.records.CNAME","title":"CNAME","text":"<pre><code>CNAME(resource_name: str, domain: str, ttl: int = 300)\n</code></pre> <p>             Bases: <code>RecordBase</code></p> <p>Canonical Name (<code>CNAME</code>) Record.</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>DNS resource name</p> required <code>domain</code> <code>str</code> <p>canonical domain for this <code>name</code></p> required <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> <code>300</code>"},{"location":"reference/nserver/records/#nserver.records.CNAME.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/records/#nserver.records.MX","title":"MX","text":"<pre><code>MX(\n    resource_name: str,\n    domain: str,\n    priority: int = 10,\n    ttl: int = 300,\n)\n</code></pre> <p>             Bases: <code>RecordBase</code></p> <p>Mail Exchange (<code>MX</code>) Record</p> See also <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.3.9</li> <li>https://en.wikipedia.org/wiki/MX_record</li> </ul> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>DNS resource name</p> required <code>domain</code> <code>str</code> <p>DNS name of mail exchange. Note: <code>domain</code> must not point to a <code>CNAME</code> record.</p> required <code>priority</code> <code>int</code> <p>mail exchange priority (<code>0</code> is highest priority)</p> <code>10</code> <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> <code>300</code>"},{"location":"reference/nserver/records/#nserver.records.MX.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/records/#nserver.records.NS","title":"NS","text":"<pre><code>NS(resource_name: str, domain: str, ttl: int = 3600)\n</code></pre> <p>             Bases: <code>CNAME</code></p> <p>Name Server (<code>NS</code>) Record.</p> See also <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.3.11</li> </ul> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>DNS resource name</p> required <code>domain</code> <code>str</code> <p>domain name of the Name Server</p> required <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> <code>3600</code>"},{"location":"reference/nserver/records/#nserver.records.NS.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/records/#nserver.records.PTR","title":"PTR","text":"<pre><code>PTR(resource_name: str, domain: str, ttl: int = 300)\n</code></pre> <p>             Bases: <code>CNAME</code></p> <p>Pointer (<code>PTR</code>) Record.</p> See also <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.3.12</li> </ul> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>DNS resource name</p> required <code>domain</code> <code>str</code> <p>domain to point to</p> required <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> <code>300</code>"},{"location":"reference/nserver/records/#nserver.records.PTR.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/records/#nserver.records.RecordBase","title":"RecordBase","text":"<pre><code>RecordBase(resource_name: str, ttl: int)\n</code></pre> <p>Base class for all DNS records.</p> <p>Note: MUST NOT be used directly</p> <p>Subclasses must set <code>_record_kwargs</code></p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>DNS resource name</p> required <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> required"},{"location":"reference/nserver/records/#nserver.records.RecordBase.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/records/#nserver.records.SOA","title":"SOA","text":"<pre><code>SOA(\n    zone_name: str,\n    primary_name_server: str,\n    admin_email: str,\n    zone_serial: int,\n    refresh_period: int = 86400,\n    retry_period: int = 7200,\n    expires: int = 3600000,\n    minimum_ttl: int = 172800,\n    ttl: int = 3600,\n)\n</code></pre> <p>             Bases: <code>RecordBase</code></p> <p>Start of Authority (`SOA``) Record</p> See also <ul> <li>https://datatracker.ietf.org/doc/html/rfc1035#section-3.3.13</li> <li>https://en.wikipedia.org/wiki/SOA_record</li> </ul> <p>Parameters:</p> Name Type Description Default <code>zone_name</code> <code>str</code> <p>name of the DNS zone</p> required <code>primary_name_server</code> <code>str</code> <p>domain name of primary name server for this domain</p> required <code>admin_email</code> <code>str</code> <p>Domain encoded email address of the administrator responsible for this zone. The part of the email address before the @ becomes the first label of the name; the domain name after the @ becomes the rest of the name. In zone-file format, dots in labels are escaped with backslashes; thus the email address john.doe@example.com would be represented in a zone file as john.doe.example.com.)</p> required <code>zone_serial</code> <code>int</code> <p>Serial number for this zone. If a secondary name server following this one observes an increase in this number, the follower will assume that the zone has been updated and initiate a zone transfer.</p> required <code>refresh_period</code> <code>int</code> <p>Number of seconds after which secondary name servers should query the master for the SOA record, to detect zone changes. Recommendation for small and stable zones: 86400 seconds (24 hours).</p> <code>86400</code> <code>retry_period</code> <code>int</code> <p>Number of seconds after which secondary name servers should retry to request the serial number from the master if the master does not respond. It must be less than Refresh. Recommendation for small and stable zones: 7200 seconds (2 hours).</p> <code>7200</code> <code>expires</code> <code>int</code> <p>Number of seconds after which secondary name servers should stop answering request for this zone if the master does not respond. This value must be bigger than the sum of Refresh and Retry. Recommendation for small and stable zones: 3600000 seconds (1000 hours).</p> <code>3600000</code> <code>minimum_ttl</code> <code>int</code> <p>Used in calculating the time to live for purposes of negative caching. Authoritative name servers take the smaller of the SOA TTL and the SOA MINIMUM to send as the SOA TTL in negative responses. Resolvers use the resulting SOA TTL to understand for how long they are allowed to cache a negative response. Recommendation for small and stable zones: 172800 seconds (2 days)</p> <code>172800</code> <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> <code>3600</code>"},{"location":"reference/nserver/records/#nserver.records.SOA.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/records/#nserver.records.SRV","title":"SRV","text":"<pre><code>SRV(\n    resource_name: str,\n    target: str,\n    port: int,\n    priority: int,\n    weight: int,\n    ttl: int = 300,\n)\n</code></pre> <p>             Bases: <code>RecordBase</code></p> <p>Service (<code>SRV</code>) Record</p> See also <ul> <li>https://datatracker.ietf.org/doc/html/rfc2782</li> </ul> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Full name of service in <code>_Service._Proto.Name</code> format.</p> required <code>target</code> <code>str</code> <p>domain name of target host</p> required <code>port</code> <code>int</code> <p>port on target host</p> required <code>priority</code> <code>int</code> <p>priority of target host. <code>0</code> is highest.</p> required <code>weight</code> <code>int</code> <p>relative weight of this <code>target</code> for targets with same <code>priority</code>. <code>0</code> is lowest.</p> required <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> <code>300</code>"},{"location":"reference/nserver/records/#nserver.records.SRV.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/records/#nserver.records.TXT","title":"TXT","text":"<pre><code>TXT(resource_name: str, text: str, ttl: int = 300)\n</code></pre> <p>             Bases: <code>RecordBase</code></p> <p>Text (<code>TXT</code>) Record</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>DNS resource name</p> required <code>text</code> <code>str</code> <p>value of the record</p> required <code>ttl</code> <code>int</code> <p>record time-to-live in seconds</p> <code>300</code>"},{"location":"reference/nserver/records/#nserver.records.TXT.to_resource_record","title":"to_resource_record","text":"<pre><code>to_resource_record() -&gt; dnslib.RR\n</code></pre> <p>Convert Record to a dnslib Resource Record</p>"},{"location":"reference/nserver/rules/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> rules","text":""},{"location":"reference/nserver/rules/#nserver.rules","title":"nserver.rules","text":""},{"location":"reference/nserver/rules/#nserver.rules.ALL_QTYPES","title":"ALL_QTYPES  <code>module-attribute</code>","text":"<pre><code>ALL_QTYPES: List[str] = list(dnslib.QTYPE.reverse.keys())\n</code></pre> <p>All supported Query Types</p> <p>New in <code>2.0</code>.</p>"},{"location":"reference/nserver/rules/#nserver.rules.ResponseFunction","title":"ResponseFunction  <code>module-attribute</code>","text":"<pre><code>ResponseFunction = Callable[[Query], RuleResult]\n</code></pre> <p>Type Alias for functions that will be called when a rule is matched</p>"},{"location":"reference/nserver/rules/#nserver.rules.RuleResult","title":"RuleResult  <code>module-attribute</code>","text":"<pre><code>RuleResult = Union[\n    Response, RecordBase, List[RecordBase], None\n]\n</code></pre> <p>Type Alias for the result of a rule response function</p>"},{"location":"reference/nserver/rules/#nserver.rules.RegexRule","title":"RegexRule","text":"<pre><code>RegexRule(\n    regex: Pattern,\n    allowed_qtypes: List[str],\n    func: ResponseFunction,\n    case_sensitive: bool = False,\n)\n</code></pre> <p>             Bases: <code>RuleBase</code></p> <p>Rule that uses the provided regex to attempt to match the query name.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>Pattern</code> <p>compiled regex for matching</p> required <code>allowed_qtypes</code> <code>List[str]</code> <p>match only the given query types</p> required <code>func</code> <code>ResponseFunction</code> <p>response function to call</p> required <code>case_sensitive</code> <code>bool</code> <p>how to case when matching if <code>False</code> will recompile <code>regex</code> with <code>re.IGNORECASE</code></p> <code>False</code>"},{"location":"reference/nserver/rules/#nserver.rules.RegexRule.get_func","title":"get_func","text":"<pre><code>get_func(query: Query) -&gt; Optional[ResponseFunction]\n</code></pre> <p>Same as parent class</p>"},{"location":"reference/nserver/rules/#nserver.rules.RuleBase","title":"RuleBase","text":"<p>Base class for all Rules to inherit from.</p>"},{"location":"reference/nserver/rules/#nserver.rules.RuleBase.get_func","title":"get_func","text":"<pre><code>get_func(query: Query) -&gt; Optional[ResponseFunction]\n</code></pre> <p>From the given query return the function to run, if any.</p> <p>If no function should be run (i.e. because it does not match the rule), then return <code>None</code>.</p> <p>This is to allow more efficient methods when determining a match and getting the rule function may be expensive (e.g. blueprints).</p>"},{"location":"reference/nserver/rules/#nserver.rules.StaticRule","title":"StaticRule","text":"<pre><code>StaticRule(\n    match_string: str,\n    allowed_qtypes: List[str],\n    func: ResponseFunction,\n    case_sensitive: bool = False,\n)\n</code></pre> <p>             Bases: <code>RuleBase</code></p> <p>Rule that matches only the given string</p> <p><code>StaticRule</code> is more efficient than using a <code>WildcardStringRule</code> for static strings.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>match_string</code> <code>str</code> <p>string to match</p> required <code>allowed_qtypes</code> <code>List[str]</code> <p>match only the given query types</p> required <code>func</code> <code>ResponseFunction</code> <p>response function to call</p> required <code>case_sensitive</code> <code>bool</code> <p>how to case when matching</p> <code>False</code>"},{"location":"reference/nserver/rules/#nserver.rules.StaticRule.get_func","title":"get_func","text":"<pre><code>get_func(query: Query) -&gt; Optional[ResponseFunction]\n</code></pre> <p>Same as parent class</p>"},{"location":"reference/nserver/rules/#nserver.rules.WildcardStringRule","title":"WildcardStringRule","text":"<pre><code>WildcardStringRule(\n    wildcard_string: str,\n    allowed_qtypes: List,\n    func: ResponseFunction,\n    case_sensitive: bool = False,\n)\n</code></pre> <p>             Bases: <code>RuleBase</code></p> <p>Rule that allows a more concise way of matching query names.</p> <p>The following substitutions can be made:</p> <ul> <li><code>*</code> will match a single domain label</li> <li><code>**</code> will match multiple domain labels</li> <li><code>base_domain</code> will match the registered domain using the Public Suffix List (PSL)</li> </ul> <p>Examples:</p> <ul> <li><code>_dmarc.{base_domain}</code></li> <li><code>*._dkim.**</code></li> <li><code>foo.*.bar.com</code></li> </ul> <p>When operating with <code>case_sensitive=False</code>, both the wildcard string and the query name are covereted to lowercase prior to matching.</p> <p>Parameters:</p> Name Type Description Default <code>wildcard_string</code> <code>str</code> <p>wildcard string to use</p> required <code>allowed_qtypes</code> <code>List</code> <p>match only the given query types</p> required <code>func</code> <code>ResponseFunction</code> <p>response function to call</p> required <code>case_sensitive</code> <code>bool</code> <p>how to case when matching</p> <code>False</code>"},{"location":"reference/nserver/rules/#nserver.rules.WildcardStringRule.get_func","title":"get_func","text":"<pre><code>get_func(query: Query) -&gt; Optional[ResponseFunction]\n</code></pre> <p>Same as parent class</p>"},{"location":"reference/nserver/rules/#nserver.rules.ZoneRule","title":"ZoneRule","text":"<pre><code>ZoneRule(\n    zone: str,\n    allowed_qtypes: List[str],\n    func: ResponseFunction,\n    case_sensitive: bool = False,\n)\n</code></pre> <p>             Bases: <code>RuleBase</code></p> <p>Rule that matches the given domain or any subdomain</p> <p>An empty zone (<code>\"\"</code>) will match any domain as this refers to the domain root (<code>.</code>).</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>str</code> <p>zone root</p> required <code>allowed_qtypes</code> <code>List[str]</code> <p>match only the given query types.</p> required <code>func</code> <code>ResponseFunction</code> <p>response function to call</p> required <code>case_sensitive</code> <code>bool</code> <p>how to case when matching</p> <code>False</code>"},{"location":"reference/nserver/rules/#nserver.rules.ZoneRule.get_func","title":"get_func","text":"<pre><code>get_func(query: Query) -&gt; Optional[ResponseFunction]\n</code></pre> <p>Same as parent class</p>"},{"location":"reference/nserver/rules/#nserver.rules.smart_make_rule","title":"smart_make_rule","text":"<pre><code>smart_make_rule(\n    rule: Union[Type[RuleBase], str, Pattern],\n    *args,\n    **kwargs\n) -&gt; RuleBase\n</code></pre> <p>Create a rule using shorthand notation.</p> <p>The exact type of rule returned depends on what is povided by <code>rule</code>.</p> <p>If rule is a</p> <ul> <li><code>RuleBase</code> class, then it is used directly.</li> <li><code>str</code> then it is checked to see if it contains substitutions. If it does then   it will be a <code>WildcardStringRule</code>, else a <code>StaticRule</code>.</li> <li><code>Pattern</code> then a <code>RegexRule</code>.</li> </ul> <p>New in <code>2.0</code></p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Union[Type[RuleBase], str, Pattern]</code> <p>input to process</p> required <code>args</code> <p>extra arguments to provide to the constructor</p> <code>()</code> <code>kwargs</code> <p>extra keyword arguments to provide to the constructor</p> <code>{}</code>"},{"location":"reference/nserver/server/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> server","text":""},{"location":"reference/nserver/server/#nserver.server","title":"nserver.server","text":""},{"location":"reference/nserver/server/#nserver.server.Blueprint","title":"Blueprint","text":"<pre><code>Blueprint(name: str)\n</code></pre> <p>             Bases: <code>Scaffold</code></p> <p>Class that can replicate many of the functions of a <code>NameServer</code>.</p> <p>They can be used to construct or extend applications.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the server. This is used for internal logging.</p> required"},{"location":"reference/nserver/server/#nserver.server.Blueprint.after_query","title":"after_query","text":"<pre><code>after_query()\n</code></pre> <p>Decorator for registering after_query hook.</p> <p>These functions are after the rule function is run and may modify the response.</p>"},{"location":"reference/nserver/server/#nserver.server.Blueprint.before_first_query","title":"before_first_query","text":"<pre><code>before_first_query()\n</code></pre> <p>Decorator for registering before_first_query hook.</p> <p>These functions are called when the server receives it's first query, but before any further processesing.</p>"},{"location":"reference/nserver/server/#nserver.server.Blueprint.before_query","title":"before_query","text":"<pre><code>before_query()\n</code></pre> <p>Decorator for registering before_query hook.</p> <p>These functions are called before processing each query.</p>"},{"location":"reference/nserver/server/#nserver.server.Blueprint.entrypoint","title":"entrypoint","text":"<pre><code>entrypoint(query: Query) -&gt; Response\n</code></pre> <p>Entrypoint into this <code>Blueprint</code>.</p> <p>This method should be passed to rules as the function to run.</p>"},{"location":"reference/nserver/server/#nserver.server.Blueprint.exception_handler","title":"exception_handler","text":"<pre><code>exception_handler(exception_class: Type[Exception])\n</code></pre> <p>Decorator for registering a function as an exception handler</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exception_class</code> <code>Type[Exception]</code> <p>The <code>Exception</code> class to register this handler for</p> required"},{"location":"reference/nserver/server/#nserver.server.Blueprint.register_after_query","title":"register_after_query","text":"<pre><code>register_after_query(\n    func: middleware.AfterQueryHook,\n) -&gt; None\n</code></pre> <p>Register a function to be run on the result of a query.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>AfterQueryHook</code> <p>the function to register</p> required"},{"location":"reference/nserver/server/#nserver.server.Blueprint.register_before_first_query","title":"register_before_first_query","text":"<pre><code>register_before_first_query(\n    func: middleware.BeforeFirstQueryHook,\n) -&gt; None\n</code></pre> <p>Register a function to be run before the first query.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>BeforeFirstQueryHook</code> <p>the function to register</p> required"},{"location":"reference/nserver/server/#nserver.server.Blueprint.register_before_query","title":"register_before_query","text":"<pre><code>register_before_query(\n    func: middleware.BeforeQueryHook,\n) -&gt; None\n</code></pre> <p>Register a function to be run before every query.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>BeforeQueryHook</code> <p>the function to register If <code>func</code> returns anything other than <code>None</code> will stop processing the incoming <code>Query</code> and continue to result processing with the return value.</p> required"},{"location":"reference/nserver/server/#nserver.server.Blueprint.register_blueprint","title":"register_blueprint","text":"<pre><code>register_blueprint(\n    blueprint: Blueprint,\n    rule_: Union[Type[RuleBase], str, Pattern],\n    *args,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Register a blueprint using <code>smart_make_rule</code>.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>blueprint</code> <code>Blueprint</code> <p>the <code>Blueprint</code> to attach</p> required <code>rule_</code> <code>Union[Type[RuleBase], str, Pattern]</code> <p>rule as per <code>nserver.rules.smart_make_rule</code></p> required <code>args</code> <p>extra arguments to provide <code>smart_make_rule</code></p> <code>()</code> <code>kwargs</code> <p>extra keyword arguments to provide <code>smart_make_rule</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>func</code> is provided in <code>kwargs</code>.</p>"},{"location":"reference/nserver/server/#nserver.server.Blueprint.register_exception_handler","title":"register_exception_handler","text":"<pre><code>register_exception_handler(\n    exception_class: Type[Exception],\n    handler: middleware.ExceptionHandler,\n) -&gt; None\n</code></pre> <p>Register an exception handler for the <code>QueryMiddleware</code></p> <p>Only one handler can exist for a given exception type.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exception_class</code> <code>Type[Exception]</code> <p>the type of exception to handle</p> required <code>handler</code> <code>ExceptionHandler</code> <p>the function to call when handling an exception</p> required"},{"location":"reference/nserver/server/#nserver.server.Blueprint.register_middleware","title":"register_middleware","text":"<pre><code>register_middleware(\n    query_middleware: middleware.QueryMiddleware,\n) -&gt; None\n</code></pre> <p>Add a <code>QueryMiddleware</code> to this server.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>query_middleware</code> <code>QueryMiddleware</code> <p>the middleware to add</p> required"},{"location":"reference/nserver/server/#nserver.server.Blueprint.register_rule","title":"register_rule","text":"<pre><code>register_rule(rule: RuleBase) -&gt; None\n</code></pre> <p>Register the given rule</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>RuleBase</code> <p>the rule to register</p> required"},{"location":"reference/nserver/server/#nserver.server.Blueprint.rule","title":"rule","text":"<pre><code>rule(\n    rule_: Union[Type[RuleBase], str, Pattern],\n    *args,\n    **kwargs\n)\n</code></pre> <p>Decorator for registering a function using <code>smart_make_rule</code>.</p> <p>Changed in <code>2.0</code>: This method now uses <code>smart_make_rule</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule_</code> <code>Union[Type[RuleBase], str, Pattern]</code> <p>rule as per <code>nserver.rules.smart_make_rule</code></p> required <code>args</code> <p>extra arguments to provide <code>smart_make_rule</code></p> <code>()</code> <code>kwargs</code> <p>extra keyword arguments to provide <code>smart_make_rule</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>func</code> is provided in <code>kwargs</code>.</p>"},{"location":"reference/nserver/server/#nserver.server.NameServer","title":"NameServer","text":"<pre><code>NameServer(name: str, settings: Optional[Settings] = None)\n</code></pre> <p>             Bases: <code>Scaffold</code></p> <p>NameServer for responding to requests.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the server. This is used for internal logging.</p> required <code>settings</code> <code>Optional[Settings]</code> <p>settings to use with this <code>NameServer</code> instance</p> <code>None</code>"},{"location":"reference/nserver/server/#nserver.server.NameServer.after_query","title":"after_query","text":"<pre><code>after_query()\n</code></pre> <p>Decorator for registering after_query hook.</p> <p>These functions are after the rule function is run and may modify the response.</p>"},{"location":"reference/nserver/server/#nserver.server.NameServer.before_first_query","title":"before_first_query","text":"<pre><code>before_first_query()\n</code></pre> <p>Decorator for registering before_first_query hook.</p> <p>These functions are called when the server receives it's first query, but before any further processesing.</p>"},{"location":"reference/nserver/server/#nserver.server.NameServer.before_query","title":"before_query","text":"<pre><code>before_query()\n</code></pre> <p>Decorator for registering before_query hook.</p> <p>These functions are called before processing each query.</p>"},{"location":"reference/nserver/server/#nserver.server.NameServer.exception_handler","title":"exception_handler","text":"<pre><code>exception_handler(exception_class: Type[Exception])\n</code></pre> <p>Decorator for registering a function as an exception handler</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exception_class</code> <code>Type[Exception]</code> <p>The <code>Exception</code> class to register this handler for</p> required"},{"location":"reference/nserver/server/#nserver.server.NameServer.raw_exception_handler","title":"raw_exception_handler","text":"<pre><code>raw_exception_handler(exception_class: Type[Exception])\n</code></pre> <p>Decorator for registering a function as an raw exception handler</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exception_class</code> <code>Type[Exception]</code> <p>The <code>Exception</code> class to register this handler for</p> required"},{"location":"reference/nserver/server/#nserver.server.NameServer.register_after_query","title":"register_after_query","text":"<pre><code>register_after_query(\n    func: middleware.AfterQueryHook,\n) -&gt; None\n</code></pre> <p>Register a function to be run on the result of a query.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>AfterQueryHook</code> <p>the function to register</p> required"},{"location":"reference/nserver/server/#nserver.server.NameServer.register_before_first_query","title":"register_before_first_query","text":"<pre><code>register_before_first_query(\n    func: middleware.BeforeFirstQueryHook,\n) -&gt; None\n</code></pre> <p>Register a function to be run before the first query.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>BeforeFirstQueryHook</code> <p>the function to register</p> required"},{"location":"reference/nserver/server/#nserver.server.NameServer.register_before_query","title":"register_before_query","text":"<pre><code>register_before_query(\n    func: middleware.BeforeQueryHook,\n) -&gt; None\n</code></pre> <p>Register a function to be run before every query.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>BeforeQueryHook</code> <p>the function to register If <code>func</code> returns anything other than <code>None</code> will stop processing the incoming <code>Query</code> and continue to result processing with the return value.</p> required"},{"location":"reference/nserver/server/#nserver.server.NameServer.register_blueprint","title":"register_blueprint","text":"<pre><code>register_blueprint(\n    blueprint: Blueprint,\n    rule_: Union[Type[RuleBase], str, Pattern],\n    *args,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Register a blueprint using <code>smart_make_rule</code>.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>blueprint</code> <code>Blueprint</code> <p>the <code>Blueprint</code> to attach</p> required <code>rule_</code> <code>Union[Type[RuleBase], str, Pattern]</code> <p>rule as per <code>nserver.rules.smart_make_rule</code></p> required <code>args</code> <p>extra arguments to provide <code>smart_make_rule</code></p> <code>()</code> <code>kwargs</code> <p>extra keyword arguments to provide <code>smart_make_rule</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>func</code> is provided in <code>kwargs</code>.</p>"},{"location":"reference/nserver/server/#nserver.server.NameServer.register_exception_handler","title":"register_exception_handler","text":"<pre><code>register_exception_handler(\n    exception_class: Type[Exception],\n    handler: middleware.ExceptionHandler,\n) -&gt; None\n</code></pre> <p>Register an exception handler for the <code>QueryMiddleware</code></p> <p>Only one handler can exist for a given exception type.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exception_class</code> <code>Type[Exception]</code> <p>the type of exception to handle</p> required <code>handler</code> <code>ExceptionHandler</code> <p>the function to call when handling an exception</p> required"},{"location":"reference/nserver/server/#nserver.server.NameServer.register_middleware","title":"register_middleware","text":"<pre><code>register_middleware(\n    query_middleware: middleware.QueryMiddleware,\n) -&gt; None\n</code></pre> <p>Add a <code>QueryMiddleware</code> to this server.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>query_middleware</code> <code>QueryMiddleware</code> <p>the middleware to add</p> required"},{"location":"reference/nserver/server/#nserver.server.NameServer.register_raw_exception_handler","title":"register_raw_exception_handler","text":"<pre><code>register_raw_exception_handler(\n    exception_class: Type[Exception],\n    handler: middleware.RawRecordExceptionHandler,\n) -&gt; None\n</code></pre> <p>Register a raw exception handler for the <code>RawRecordMiddleware</code>.</p> <p>Only one handler can exist for a given exception type.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exception_class</code> <code>Type[Exception]</code> <p>the type of exception to handle</p> required <code>handler</code> <code>RawRecordExceptionHandler</code> <p>the function to call when handling an exception</p> required"},{"location":"reference/nserver/server/#nserver.server.NameServer.register_raw_middleware","title":"register_raw_middleware","text":"<pre><code>register_raw_middleware(\n    raw_middleware: middleware.RawRecordMiddleware,\n) -&gt; None\n</code></pre> <p>Add a <code>RawRecordMiddleware</code> to this server.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>raw_middleware</code> <code>RawRecordMiddleware</code> <p>the middleware to add</p> required"},{"location":"reference/nserver/server/#nserver.server.NameServer.register_rule","title":"register_rule","text":"<pre><code>register_rule(rule: RuleBase) -&gt; None\n</code></pre> <p>Register the given rule</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>RuleBase</code> <p>the rule to register</p> required"},{"location":"reference/nserver/server/#nserver.server.NameServer.rule","title":"rule","text":"<pre><code>rule(\n    rule_: Union[Type[RuleBase], str, Pattern],\n    *args,\n    **kwargs\n)\n</code></pre> <p>Decorator for registering a function using <code>smart_make_rule</code>.</p> <p>Changed in <code>2.0</code>: This method now uses <code>smart_make_rule</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule_</code> <code>Union[Type[RuleBase], str, Pattern]</code> <p>rule as per <code>nserver.rules.smart_make_rule</code></p> required <code>args</code> <p>extra arguments to provide <code>smart_make_rule</code></p> <code>()</code> <code>kwargs</code> <p>extra keyword arguments to provide <code>smart_make_rule</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>func</code> is provided in <code>kwargs</code>.</p>"},{"location":"reference/nserver/server/#nserver.server.NameServer.run","title":"run","text":"<pre><code>run() -&gt; int\n</code></pre> <p>Start running the server</p> <p>Returns:</p> Type Description <code>int</code> <p><code>exit_code</code>, <code>0</code> if exited normally</p>"},{"location":"reference/nserver/server/#nserver.server.Scaffold","title":"Scaffold","text":"<pre><code>Scaffold(name: str)\n</code></pre> <p>Base class for shared functionality between <code>NameServer</code> and <code>Blueprint</code></p> <p>New in <code>2.0</code>.</p> <p>Attributes:</p> Name Type Description <code>rules</code> <code>List[RuleBase]</code> <p>registered rules</p> <code>hook_middleware</code> <p>hook middleware</p> <code>exception_handler_middleware</code> <p>Query exception handler middleware</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the server. This is used for internal logging.</p> required"},{"location":"reference/nserver/server/#nserver.server.Scaffold.after_query","title":"after_query","text":"<pre><code>after_query()\n</code></pre> <p>Decorator for registering after_query hook.</p> <p>These functions are after the rule function is run and may modify the response.</p>"},{"location":"reference/nserver/server/#nserver.server.Scaffold.before_first_query","title":"before_first_query","text":"<pre><code>before_first_query()\n</code></pre> <p>Decorator for registering before_first_query hook.</p> <p>These functions are called when the server receives it's first query, but before any further processesing.</p>"},{"location":"reference/nserver/server/#nserver.server.Scaffold.before_query","title":"before_query","text":"<pre><code>before_query()\n</code></pre> <p>Decorator for registering before_query hook.</p> <p>These functions are called before processing each query.</p>"},{"location":"reference/nserver/server/#nserver.server.Scaffold.exception_handler","title":"exception_handler","text":"<pre><code>exception_handler(exception_class: Type[Exception])\n</code></pre> <p>Decorator for registering a function as an exception handler</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exception_class</code> <code>Type[Exception]</code> <p>The <code>Exception</code> class to register this handler for</p> required"},{"location":"reference/nserver/server/#nserver.server.Scaffold.register_after_query","title":"register_after_query","text":"<pre><code>register_after_query(\n    func: middleware.AfterQueryHook,\n) -&gt; None\n</code></pre> <p>Register a function to be run on the result of a query.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>AfterQueryHook</code> <p>the function to register</p> required"},{"location":"reference/nserver/server/#nserver.server.Scaffold.register_before_first_query","title":"register_before_first_query","text":"<pre><code>register_before_first_query(\n    func: middleware.BeforeFirstQueryHook,\n) -&gt; None\n</code></pre> <p>Register a function to be run before the first query.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>BeforeFirstQueryHook</code> <p>the function to register</p> required"},{"location":"reference/nserver/server/#nserver.server.Scaffold.register_before_query","title":"register_before_query","text":"<pre><code>register_before_query(\n    func: middleware.BeforeQueryHook,\n) -&gt; None\n</code></pre> <p>Register a function to be run before every query.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>BeforeQueryHook</code> <p>the function to register If <code>func</code> returns anything other than <code>None</code> will stop processing the incoming <code>Query</code> and continue to result processing with the return value.</p> required"},{"location":"reference/nserver/server/#nserver.server.Scaffold.register_blueprint","title":"register_blueprint","text":"<pre><code>register_blueprint(\n    blueprint: Blueprint,\n    rule_: Union[Type[RuleBase], str, Pattern],\n    *args,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Register a blueprint using <code>smart_make_rule</code>.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>blueprint</code> <code>Blueprint</code> <p>the <code>Blueprint</code> to attach</p> required <code>rule_</code> <code>Union[Type[RuleBase], str, Pattern]</code> <p>rule as per <code>nserver.rules.smart_make_rule</code></p> required <code>args</code> <p>extra arguments to provide <code>smart_make_rule</code></p> <code>()</code> <code>kwargs</code> <p>extra keyword arguments to provide <code>smart_make_rule</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>func</code> is provided in <code>kwargs</code>.</p>"},{"location":"reference/nserver/server/#nserver.server.Scaffold.register_exception_handler","title":"register_exception_handler","text":"<pre><code>register_exception_handler(\n    exception_class: Type[Exception],\n    handler: middleware.ExceptionHandler,\n) -&gt; None\n</code></pre> <p>Register an exception handler for the <code>QueryMiddleware</code></p> <p>Only one handler can exist for a given exception type.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exception_class</code> <code>Type[Exception]</code> <p>the type of exception to handle</p> required <code>handler</code> <code>ExceptionHandler</code> <p>the function to call when handling an exception</p> required"},{"location":"reference/nserver/server/#nserver.server.Scaffold.register_middleware","title":"register_middleware","text":"<pre><code>register_middleware(\n    query_middleware: middleware.QueryMiddleware,\n) -&gt; None\n</code></pre> <p>Add a <code>QueryMiddleware</code> to this server.</p> <p>New in <code>2.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>query_middleware</code> <code>QueryMiddleware</code> <p>the middleware to add</p> required"},{"location":"reference/nserver/server/#nserver.server.Scaffold.register_rule","title":"register_rule","text":"<pre><code>register_rule(rule: RuleBase) -&gt; None\n</code></pre> <p>Register the given rule</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>RuleBase</code> <p>the rule to register</p> required"},{"location":"reference/nserver/server/#nserver.server.Scaffold.rule","title":"rule","text":"<pre><code>rule(\n    rule_: Union[Type[RuleBase], str, Pattern],\n    *args,\n    **kwargs\n)\n</code></pre> <p>Decorator for registering a function using <code>smart_make_rule</code>.</p> <p>Changed in <code>2.0</code>: This method now uses <code>smart_make_rule</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule_</code> <code>Union[Type[RuleBase], str, Pattern]</code> <p>rule as per <code>nserver.rules.smart_make_rule</code></p> required <code>args</code> <p>extra arguments to provide <code>smart_make_rule</code></p> <code>()</code> <code>kwargs</code> <p>extra keyword arguments to provide <code>smart_make_rule</code></p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>func</code> is provided in <code>kwargs</code>.</p>"},{"location":"reference/nserver/settings/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> settings","text":""},{"location":"reference/nserver/settings/#nserver.settings","title":"nserver.settings","text":""},{"location":"reference/nserver/settings/#nserver.settings.Settings","title":"Settings  <code>dataclass</code>","text":"<p>Dataclass for NameServer settings</p> <p>Attributes:</p> Name Type Description <code>server_transport</code> <code>str</code> <p>What <code>Transport</code> to use. See <code>nserver.server.TRANSPORT_MAP</code> for options.</p> <code>server_address</code> <code>str</code> <p>What address <code>server_transport</code> will bind to.</p> <code>server_port</code> <code>int</code> <p>what port <code>server_port</code> will bind to.</p>"},{"location":"reference/nserver/transport/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> transport","text":""},{"location":"reference/nserver/transport/#nserver.transport","title":"nserver.transport","text":""},{"location":"reference/nserver/transport/#nserver.transport.CachedConnection","title":"CachedConnection  <code>dataclass</code>","text":"<p>Dataclass for storing information about a TCP connection</p> <p>Attributes:</p> Name Type Description <code>connection</code> <code>socket</code> <p>the actual socket we are connected to</p> <code>remote_address</code> <code>Tuple[str, int]</code> <p>the socket's peername</p> <code>last_data_time</code> <code>float</code> <p>timestamp when we last received data from this socket</p> <code>selector_key</code> <code>SelectorKey</code> <p>key used by our TCP Transport's selector</p> <code>cache_key</code> <code>CacheKey</code> <p>the key used to store this connection in the cache</p>"},{"location":"reference/nserver/transport/#nserver.transport.MessageContainer","title":"MessageContainer","text":"<pre><code>MessageContainer(\n    raw_data: bytes,\n    transport: TransportBase,\n    transport_data: Any,\n    remote_client: Union[str, Tuple[str, int]],\n)\n</code></pre> <p>Class for holding DNS messages and the transport they originated from.</p> <p>Used to simplify the interface (and allow for threading etc later).</p> <p>Create new message container</p> <p>Parameters:</p> Name Type Description Default <code>raw_data</code> <code>bytes</code> <p>The raw message pulled from the transport. It will parsed as a DNS message.</p> required <code>transport</code> <code>TransportBase</code> <p>The transport instance that created this message (e.g. <code>self</code>). Messages must only be returned to this transport instance when responding (even if it would be possible for another instance to respond (e.g. with UDP processing)). As such transports should rely on only receiving messages that they created (opposed to <code>assert message.transport is self</code>).</p> required <code>transport_data</code> <code>Any</code> <p>Data that the transport instance wishes to store with this message for later use. What is stored is up to the transport, and it is up to the transport implementation to correctly handle it.</p> required <code>remote_client</code> <code>Union[str, Tuple[str, int]]</code> <p>Representation of the remote client that sent this DNS request. This value is primarily to allow logging and debugging of invalid requests. Whilst transport instances must set this value, they should NOT use it for processing.</p> required"},{"location":"reference/nserver/transport/#nserver.transport.MessageContainer.get_response_bytes","title":"get_response_bytes","text":"<pre><code>get_response_bytes()\n</code></pre> <p>Convert response object to bytes</p>"},{"location":"reference/nserver/transport/#nserver.transport.TCPMessageData","title":"TCPMessageData  <code>dataclass</code>","text":"<p>Message.transport_data for TCP transports</p> <p>Attributes:</p> Name Type Description <code>socket</code> <code>socket</code> <p>the socket this message was received on</p>"},{"location":"reference/nserver/transport/#nserver.transport.TCPv4Transport","title":"TCPv4Transport","text":"<pre><code>TCPv4Transport(settings: Settings)\n</code></pre> <p>             Bases: <code>TransportBase</code></p> <p>Transport class for IPv4 TCP.</p> References <ul> <li>https://tools.ietf.org/html/rfc7766#section-8</li> </ul>"},{"location":"reference/nserver/transport/#nserver.transport.TCPv4Transport.receive_message","title":"receive_message","text":"<pre><code>receive_message() -&gt; MessageContainer\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.TCPv4Transport.send_message_response","title":"send_message_response","text":"<pre><code>send_message_response(message: MessageContainer) -&gt; None\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.TCPv4Transport.start_server","title":"start_server","text":"<pre><code>start_server(timeout: int = 60) -&gt; None\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.TCPv4Transport.stop_server","title":"stop_server","text":"<pre><code>stop_server() -&gt; None\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.TcpState","title":"TcpState","text":"<p>             Bases: <code>IntEnum</code></p> <p>State of a TCP connection</p>"},{"location":"reference/nserver/transport/#nserver.transport.TransportBase","title":"TransportBase","text":"<pre><code>TransportBase(settings: Settings)\n</code></pre> <p>Base class for all transports</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Settings</code> <p>settings of the server this transport is attached to</p> required"},{"location":"reference/nserver/transport/#nserver.transport.TransportBase.receive_message","title":"receive_message","text":"<pre><code>receive_message() -&gt; MessageContainer\n</code></pre> <p>Receive a message from the running server</p>"},{"location":"reference/nserver/transport/#nserver.transport.TransportBase.send_message_response","title":"send_message_response","text":"<pre><code>send_message_response(message: MessageContainer) -&gt; None\n</code></pre> <p>Respond to a message that was received by the server</p>"},{"location":"reference/nserver/transport/#nserver.transport.TransportBase.start_server","title":"start_server","text":"<pre><code>start_server(timeout: int = 60) -&gt; None\n</code></pre> <p>Start transport's server</p>"},{"location":"reference/nserver/transport/#nserver.transport.TransportBase.stop_server","title":"stop_server","text":"<pre><code>stop_server() -&gt; None\n</code></pre> <p>Stop transport's server</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPMessageData","title":"UDPMessageData  <code>dataclass</code>","text":"<p>Message.transport_data for UDP transports</p> <p>Attributes:</p> Name Type Description <code>remote_address</code> <code>Tuple[str, int]</code> <p>UDP peername that this message was received from</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPv4Transport","title":"UDPv4Transport","text":"<pre><code>UDPv4Transport(settings: Settings)\n</code></pre> <p>             Bases: <code>TransportBase</code></p> <p>Transport class for IPv4 UDP.</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPv4Transport.receive_message","title":"receive_message","text":"<pre><code>receive_message() -&gt; MessageContainer\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPv4Transport.send_message_response","title":"send_message_response","text":"<pre><code>send_message_response(message: MessageContainer) -&gt; None\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPv4Transport.start_server","title":"start_server","text":"<pre><code>start_server(timeout=60) -&gt; None\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPv4Transport.stop_server","title":"stop_server","text":"<pre><code>stop_server() -&gt; None\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPv6Transport","title":"UDPv6Transport","text":"<pre><code>UDPv6Transport(settings: Settings)\n</code></pre> <p>             Bases: <code>UDPv4Transport</code></p> <p>Transport class for IPv6 UDP.</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPv6Transport.receive_message","title":"receive_message","text":"<pre><code>receive_message() -&gt; MessageContainer\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPv6Transport.send_message_response","title":"send_message_response","text":"<pre><code>send_message_response(message: MessageContainer) -&gt; None\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPv6Transport.start_server","title":"start_server","text":"<pre><code>start_server(timeout=60) -&gt; None\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.UDPv6Transport.stop_server","title":"stop_server","text":"<pre><code>stop_server() -&gt; None\n</code></pre> <p>As per parent class</p>"},{"location":"reference/nserver/transport/#nserver.transport.get_tcp_info","title":"get_tcp_info","text":"<pre><code>get_tcp_info(connection: socket.socket) -&gt; Tuple\n</code></pre> <p>Get <code>socket.TCP_INFO</code> from socket</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>socket</code> <p>the socket to inspect</p> required <p>Returns:</p> Type Description <code>Tuple</code> <p>Tuple of 28 integers.</p> <p>Strictly speaking the data returned is platform dependent as will be whatever is in <code>/usr/include/linux/tcp.h</code>. For our purposes we cap it at the first 28 values.</p>"},{"location":"reference/nserver/transport/#nserver.transport.get_tcp_state","title":"get_tcp_state","text":"<pre><code>get_tcp_state(connection: socket.socket) -&gt; TcpState\n</code></pre> <p>Get the <code>TcpState</code> of a socket</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>socket</code> <p>the socket to inspect</p> required"},{"location":"reference/nserver/transport/#nserver.transport.recv_data","title":"recv_data","text":"<pre><code>recv_data(\n    data_length: int,\n    connection: socket.socket,\n    existing_data: bytes = b\"\",\n    timeout: int = 10,\n) -&gt; bytes\n</code></pre> <p>Receive a given amount of data from a socket.</p> <p>Parameters:</p> Name Type Description Default <code>data_length</code> <code>int</code> <p>number of bytes to receive</p> required <code>connection</code> <code>socket</code> <p>the socket to receive data from</p> required <code>existing_data</code> <code>bytes</code> <p>data that is added to the response before we collect further data</p> <code>b''</code> <code>timeout</code> <code>int</code> <p>time before giving up in seconds</p> <code>10</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>timeout was reached before we finished receiving the data</p>"},{"location":"reference/nserver/util/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> util","text":""},{"location":"reference/nserver/util/#nserver.util","title":"nserver.util","text":""},{"location":"reference/nserver/util/#nserver.util.is_unsigned_int_size","title":"is_unsigned_int_size","text":"<pre><code>is_unsigned_int_size(\n    value: int,\n    bits: int,\n    *,\n    throw_error: bool = False,\n    value_name: str = \"value\"\n) -&gt; bool\n</code></pre> <p>Check if a given integer fits within an unsigned integer of <code>bits</code> bits.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>integer to check</p> required <code>bits</code> <code>int</code> <p>number of bits, must be <code>&gt;0</code>.</p> required <code>throw_error</code> <code>bool</code> <p>throw a <code>ValueError</code> if the result is <code>False</code></p> <code>False</code> <code>value_name</code> <code>str</code> <p>name to use when throwing an error</p> <code>'value'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if invalid <code>bits</code> provided</p> <code>ValueError</code> <p>if <code>throw_error</code> is <code>True</code> and the result would be <code>False</code>.</p>"}]}